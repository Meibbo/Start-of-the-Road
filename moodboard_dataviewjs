```dataviewjs
// ====== CONFIG ======
const DAILY_FOLDER = "Daily Notes";
const FULL_MOON = "🌕";
const HALF_MOON = "🌗";
const EMPTY_MOON = "🌑";
const FACES = ["😞","☹️","😕","😐","🙂","😃","😎"];
// ======================

(async () => {
  const weekName = dv.current().file.name;
  const weekPage = dv.page(weekName);

  function upToStrings(up){
    if(up === undefined || up === null) return [];
    if(Array.isArray(up)) return up.map(x => String(x));
    return [String(up)];
  }
  function stripBrackets(s){ return String(s).replace(/^\[\[|\]\]$/g, "").trim(); }
  function upRefersToWeek(upStr){
    const cleaned = stripBrackets(upStr);
    if(cleaned === weekName) return true;
    if(weekPage && String(upStr).includes(weekPage.file.path)) return true;
    if(String(upStr).includes(weekName)) return true;
    return false;
  }

  // pick pages source
  let folderPages = dv.pages(`"${DAILY_FOLDER}"`);
  if(!folderPages || folderPages.length === 0) folderPages = dv.pages();
  let candidates = folderPages.where(p => p.up).array();
  let matched = candidates.filter(p => upToStrings(p.up).some(u => upRefersToWeek(u)));

  // compute stats for header
  const numericScores = matched.map(p => Number(p.score)).filter(n => Number.isFinite(n));
  const avg = numericScores.length ? (numericScores.reduce((a,b) => a+b,0) / numericScores.length) : null;
  const mn  = numericScores.length ? Math.min(...numericScores) : null;
  const mx  = numericScores.length ? Math.max(...numericScores) : null;

  if(!matched.length){
    dv.paragraph(`No daily notes found that link to **${weekName}** via the \`up\` property.`);
    if(candidates.length){
      dv.paragraph("Diagnostic: pages with an `up` property (first 50):");
      const diag = candidates.slice(0,50).map(p => [p.file.link, upToStrings(p.up).map(stripBrackets).join(" / ")]);
      dv.table(["Page","up (normalized)"], diag);
    } else dv.paragraph("No pages with an `up` property were found in the selected folder/vault.");
    return;
  }

  // sort and build table rows but create DOM elements for interactive moons
  matched.sort((a,b) => a.file.name.localeCompare(b.file.name));

  // header string with stats `[A: x.x Mn: x.x Mx: x.x]`
  const headerRating = `Rating${ avg !== null ? ` [A: ${avg.toFixed(1)} Mn: ${mn.toFixed(1)} Mx: ${mx.toFixed(1)}]` : "" }`;

  // helper to pick face according to rules
  function pickFace(val){
    if(!Number.isFinite(val)) return "—";
    if(val <= 1) return FACES[0];
    if(val <= 2) return FACES[1];
    if(val <= 3) return FACES[2];
    if(val <= 4) return FACES[3];
    if(val <= 5) return FACES[4];
    if(val <= 6.2) return FACES[5];
    return FACES[6];
  }

  // write score into YAML frontmatter (create frontmatter if missing).
  async function writeScoreToFile(filePath, value){
    try{
      const af = app.vault.getAbstractFileByPath(filePath);
      if(!af) throw new Error("file not found: " + filePath);
      // TFile expected
      const tfile = af;
      let content = await app.vault.read(tfile);

      // find frontmatter
      const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if(!fmMatch){
        // no frontmatter: prepend
        const fm = `---\nscore: ${value}\n---\n\n`;
        await app.vault.modify(tfile, fm + content);
        return true;
      } else {
        let fm = fmMatch[1];
        if(/(^|\n)score\s*:/m.test(fm)){
          // replace existing score line inside fm
          const newFm = fm.replace(/(^|\n)score\s*:\s*.*(?=$|\n)/m, match => `\nscore: ${value}`);
          const newContent = content.replace(fm, newFm);
          await app.vault.modify(tfile, newContent);
          return true;
        } else {
          // inject score into frontmatter (before closing ---)
          const insertPoint = fmMatch.index + fmMatch[0].lastIndexOf("\n---");
          // simpler: replace whole match with updated block
          const newFmBlock = `---\n${fm}\nscore: ${value}\n---`;
          const newContent = content.replace(fmMatch[0], newFmBlock);
          await app.vault.modify(tfile, newContent);
          return true;
        }
      }
    } catch(e){
      console.error("Error writing score:", e);
      throw e;
    }
  }

  // helper to render moon string by value (0..7) -> spans for each slot
  function renderMoonsForValue(value){
    // value is number from 0 to 7 possibly with .5
    let fullCount = Math.floor(value);
    const decimal = value - fullCount;
    const half = decimal >= 0.5 ? 1 : 0;
    const empty = 7 - fullCount - half;
    return FULL_MOON.repeat(fullCount) + (half ? HALF_MOON : "") + EMPTY_MOON.repeat(Math.max(0, empty));
  }

  // Build rows for dv.table but for rating we will temporarily put a placeholder element and then replace it in DOM after the table is rendered
  const rows = matched.map(p => [p.file.link, ""]); // second cell empty for now
  dv.table(["Day", headerRating], rows);

  // After dv.table rendered, find the table and replace second cell contents with interactive moon widgets
  // dv.table inserts a table in the last rendered container; locate it with a querySelector
  const container = dv.container; // Dataview container element for this block
  // find the last table inside container
  const table = container.querySelector("table:last-of-type");
  if(!table) return;

  // iterate rows in DOM and matched array in same order
  const tbody = table.querySelector("tbody");
  if(!tbody) return;
  const trList = Array.from(tbody.querySelectorAll("tr"));
  for(let i=0;i<trList.length && i<matched.length;i++){
    const p = matched[i];
    const tr = trList[i];
    const tdRating = tr.children[1]; // second column
    tdRating.innerHTML = ""; // clear placeholder

    // current numeric value (may be non-integer), clamp 0..7
    let rawScore = Number(p.score);
    if(!Number.isFinite(rawScore)) rawScore = NaN;

    // build a container for interactive moons + face
    const wrapper = document.createElement("span");
    wrapper.style.cursor = "pointer";
    wrapper.style.userSelect = "none";
    wrapper.style.display = "inline-flex";
    wrapper.style.alignItems = "center";
    wrapper.style.gap = "6px";

    // display element for moons (we will place 7 slots)
    const moonsContainer = document.createElement("span");
    moonsContainer.style.display = "inline-flex";
    moonsContainer.style.gap = "0px";
    moonsContainer.style.alignItems = "center";

    // function to update visual display based on a value (for preview / final)
    function updateMoonsVisual(targetVal){
      // remove all children and re-create visual using spans (one per slot)
      moonsContainer.innerHTML = "";
      const val = Number.isFinite(targetVal) ? Math.max(0, Math.min(7, targetVal)) : 0;
      const whole = Math.floor(val);
      const dec = val - whole;
      for(let slot=0; slot<7; slot++){
        const span = document.createElement("span");
        span.style.display = "inline-block";
        span.style.padding = "0 2px";
        span.style.fontSize = "18px";
        // decide glyph for this slot: full / half / empty
        if(slot < whole){
          span.textContent = FULL_MOON;
        } else if(slot === whole && dec >= 0.5){
          span.textContent = HALF_MOON;
        } else {
          span.textContent = EMPTY_MOON;
        }
        moonsContainer.appendChild(span);
      }
    }

    // face element
    const faceSpan = document.createElement("span");
    faceSpan.style.marginLeft = "6px";
    faceSpan.textContent = pickFace(rawScore);

    // small tooltip indicator (title attribute on wrapper)
    wrapper.title = Number.isFinite(rawScore) ? `${rawScore.toFixed(1)}/7` : `—/7`;

    // initial render
    updateMoonsVisual(Number.isFinite(rawScore) ? rawScore : 0);

    // overlay preview element (small floating bubble to show candidate)
    const previewBubble = document.createElement("span");
    previewBubble.style.position = "absolute";
    previewBubble.style.pointerEvents = "none";
    previewBubble.style.padding = "2px 6px";
    previewBubble.style.borderRadius = "6px";
    previewBubble.style.fontSize = "12px";
    previewBubble.style.background = "var(--background-modifier-card)"; // uses theme var
    previewBubble.style.boxShadow = "var(--shadow-small)";
    previewBubble.style.display = "none";
    previewBubble.style.zIndex = 9999;

    // insert wrapper and bubble into tdRating (position relative)
    tdRating.style.position = "relative";
    wrapper.appendChild(moonsContainer);
    wrapper.appendChild(document.createTextNode(" | "));
    wrapper.appendChild(faceSpan);
    tdRating.appendChild(wrapper);
    tdRating.appendChild(previewBubble);

    // helpers to compute candidate value from a mouse event over moonsContainer
    function computeCandidateValueFromEvent(ev){
      const rect = moonsContainer.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const slotWidth = rect.width / 7;
      let slot = Math.floor(x / slotWidth); // 0..6
      if(slot < 0) slot = 0;
      if(slot > 6) slot = 6;
      const inSlotX = x - (slot * slotWidth);
      const candidate = (inSlotX < slotWidth/2) ? (slot + 0.5) : (slot + 1.0);
      // clamp to 0.5..7.0 but allow 0.5 for first slot left half
      return Math.max(0.5, Math.min(7.0, candidate));
    }

    // mousemove -> show preview and highlight moons
    moonsContainer.addEventListener("mousemove", (ev) => {
      const cand = computeCandidateValueFromEvent(ev);
      // update visual to candidate
      updateMoonsVisual(cand);
      // update preview bubble
      previewBubble.textContent = `Set to ${cand.toFixed(1)}/7`;
      previewBubble.style.display = "block";
      // position bubble above cursor inside td
      const tdRect = tdRating.getBoundingClientRect();
      previewBubble.style.left = Math.max(6, ev.clientX - tdRect.left - 30) + "px";
      previewBubble.style.top = Math.max(2, ev.clientY - tdRect.top - 36) + "px";
      wrapper.title = `Click to set ${cand.toFixed(1)}/7`;
    });

    // mouseleave -> restore to actual stored value visual
    moonsContainer.addEventListener("mouseleave", () => {
      updateMoonsVisual(Number.isFinite(rawScore) ? rawScore : 0);
      previewBubble.style.display = "none";
      wrapper.title = Number.isFinite(rawScore) ? `${rawScore.toFixed(1)}/7` : `—/7`;
    });

    // click handler -> write the chosen candidate into file, then update UI
    moonsContainer.addEventListener("click", async (ev) => {
      const cand = computeCandidateValueFromEvent(ev);
      // optimistic UI change: lock UI
      wrapper.style.opacity = "0.6";
      try{
        await writeScoreToFile(p.file.path, cand);
        // update stored rawScore and face, tooltip, and visual (final)
        rawScore = cand;
        updateMoonsVisual(rawScore);
        faceSpan.textContent = pickFace(rawScore);
        wrapper.title = `${rawScore.toFixed(1)}/7`;
        // small saved flash
        previewBubble.textContent = `Saved ${rawScore.toFixed(1)}/7`;
        previewBubble.style.display = "block";
        setTimeout(()=> previewBubble.style.display = "none", 900);
      } catch(e){
        previewBubble.textContent = `Error`;
        previewBubble.style.display = "block";
        console.error(e);
      } finally {
        wrapper.style.opacity = "1";
      }
    });

    // final initial state (ensures face is correct)
    faceSpan.textContent = pickFace(rawScore);
  }

})();
```
